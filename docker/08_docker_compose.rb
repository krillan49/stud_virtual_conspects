puts '                                             Docker Compose'

# https://docs.docker.com/compose/

# docker compose (с пробелом) - это новый вариант compose на Go. Изначальный вариант compose на python, называемый docker-compose (команды были тоже с дефисом) устарел, и разработка перешла на v2.

# Docker Compose - это надстройка над Докером, нужна для того чтобы запустить многоконтейнерные Docker-приложения. Позволяет поместить в отдельный фаил все инструкции, что мы прописываем отдельными командами, настройки, образы, порты и потом просто запустить все одной командой.

# Docker Compose позволяет подключить сразу множество образов, указывать связь между ними и добавлять к ним характеристики и настройки. Например, можно подключить языки Джава, Python, C++, PHP и к ним дополнительно настроить сервера, среды разработки и все это в одном файле.

# docker-compose.yml - файл используется для описания всех связанных с проектом контейнеров, их запуска и взаимодействия между ними, там можно указать образы которые будут подключены, какие у них будут характеристики, возможности итд. При запуске проэкта эти образы будут либо скачаны либо сразу запущены.

# При построении файла Compose нужно указать сервисы и их характеристики. Каждый сервис имеет свой контейнер и все эти контейнеры имеют друг в друга доступ

# В Докер Хабе, на странице образа, внизу есть содержание для фаила docker-compose.yml по которому можно сбилдить точно такой же образ. Так же там ниже есть список всех переменных которые можно дописать дополнительно(например изменение логина, хоста итд)


# $ docker compose version                 => Docker Compose version vN.N.N



puts '                                       Параметры docker-compose.yml'

# docker-compose.yml  - пример где описано 3 сервиса: СУБД PostgreSQL, графический интерфейс phpmyadmin и проект на Джанго, которй будет собираться от Dockerfile(Python+Django)

# Каждый сервис из docker-compose.yml можно модифицировать, например поменять значение параметра "image", подключив другой образ, например "mariadb" вместо "mysql", поменять и другие настройки, например пароль из парапметра "MYSQL_ROOT_PASSWORD", добавить новые параметры или убрать какоето.

# Можно добавить новый сервис, написав его настройки вручную, скопировать с докерхаб, а можно собрать образ для него по отдельному Dockerfile

# Если нескольо сервисов имеют порты, то стоит задать им разные порты для хост маштины, чтобы заходить на локалхосты уже в 2х вкладках в разных портах для разных сервисов и чтобы при этом не было конфликтов

# Можно указать в docker-compose файле и настройки томов, тоесть какие данные и где будут сохраняться. Тоесть указать папку в проекте и папку на хост-машине.

# Стоит обратить внимание на наличие в коде хаба команд "comand"(аналог CMD из докерфаила) и добавить ее(тк она исполняется при каждом запуске)


# $ docker compose run django django-admin startproject itproger .          - обращаемся к контейнеру "django" описанному в сервисе в docker-compose и передаем в него команду "django-admin startproject my_project .", чтобы создать новый проекта Джанго в текущей директоии
# $ docker compose up     - все равно необходимо чтобы запустить контейнеры на постоянную обработку(тоесть например запустить сервер). Тут, чтобы зайти на указанный нами localhost:8081 и запустить приложение Джанга
# (?? Потом проверить Хз как это работает, создает новые контейнеры, когда сервис запущен или нет ??):
# $ docker compose run django pyton manage.py migrate          - команда migrate выполнит миграции (создаст таблицы по умолчанию)
# $ docker compose run django pyton manage.py createsuperuser  - команда createsuperuser запускает создание суперпользователя



puts '                                       Сборка и использование образа'

# -f   - флаг для всех "docker compose" команд. Если название docker-compose-фаила нестандартное, например "docker-compose.dev.yml" то нужно его дополнительно указывать под этим флагом


# 1. build - команда собирает образы на основе сервисов docker-compose.yml, получает оттуда Dockerfile или стягивает необходимые образы и устанавливает всё остальное из docker-compose.yml. При повтороном запуске пересоберет тот же образ а не создаст новый.

# $ docker compose build                            - сборка образов для всех сервисов описанных в фаиле docker-compose.yml
# $ docker compose build service_name               - сборка образа для конкретного сервиса из docker-compose.yml
# $ docker compose -f docker-compose.dev.yml build  - собрать на основе конкретного docker-compose фаила


# 2. up - команда запуска проекта, который был собран(build) на основе сервисов из docker-compose.yml, создает и запускает контейнеры для каждого сервиса. При повторном запуске запустит те же контейнеры, что были ранее созданы.

# --build    - флаг команды up чтобы пересобрать образы перед тем, как запустить их. Тоже что и запуск "build" и "up" отдельно. Удобно, если внесены изменения в код приложения, Dockerfile или docker-compose.yml

# $ docker compose up             - запуск контейеров всех сервисов (Ctrl + C выход из режима работы приложения в консоли)
# $ docker compose up -d          - запуск контейнеров всех сервисов в фоновом режиме
# $ docker compose up some        - запуск конкретного сервиса some и всех связанных с ним сервисов (depends_on)
# $ docker compose up --build     - запуск всех сервисов, с предварительной пересборкой образов для них
# $ docker compose -f docker-compose.prod.yml up --build    - собрать и запустить на основе конкретного docker-compose фаила

# Результат работы веб приложения можно увидеть в браузере, если открыть 0.0.0.0 с нужным портом, например 0.0.0.0:3000


# 3. run - команда собирает образы (как build), создает на основе них и запускает контейнер (как up) для ?одного? указанного сервиса (имя сервиса из docker-compose.yml) и дополнительно может передать в контейнер для исполнения команду, которая заменит собой команду при запуске по умолчанию, если не передавать команду то по умолчанию исполнит команду этого сервиса из command или из CMD докерфаила. При повторных запусках будет каждый раз создавать новый контейнер

# $ docker compose run [OPTIONS] SERVICE [COMMAND]
# SERVICE - имя сервиса из `docker-compose.yml`, для которого нужно запустить новый контейнер
# COMMAND - команда (и арументы для нее), которую нужно выполнить внутри контейнера. Если команда не указана, то будет использоваться команда по умолчанию из `Dockerfile` или из `docker-compose.yml`, а если команда указана то она заменит собой  команду по умолчанию

# --rm               - удалить контейнер после завершения его работы
# --service-ports    - пробросить порт, заданный в сервисе, в контейнер (по умолчанию `run` порты не пробрасывает)
# -d или --detach    - запускает контейнер в фоновом режиме
# --name             - указывает имя контейнера. (По умолчанию, Docker создаст имя автоматически)
# -e или --env       - устанавливает переменные окружения для контейнера. Можно указать несколько переменных, повторяя флаг.
# --user             - задает пользователя и группу, от чьего имени будет запущен командный процесс в контейнере.

# $ docker compose run web                               - запуск сервиса web с использованием команды по умолчанию
# $ docker compose run web rake db:create                - запуск сервиса web и передача команды rake db:create в контейнер
# $ docker compose -f docker-compose.dev.yml run web rake db:create  - если имя docker-compose-фаила нестандартное
# $ docker compose run --rm --service-ports ruby_dev     - с пробросам портов, например если команда по умолчанию запустит терминал bash, который станет средой разработки


# 4. exec - если нужно работать внутри терминала запущенного контейнера, то можно открыть новый терминал и выполнить эту команду. Эта команда откроет указанную в параметре оболочку внутри выбранного контейнера, и позврлит запускать ее команды.

# $ docker compose exec web bash               - работать с терминалом bash внутри контейнера (запустить в новом терминале)
# $ docker compose -f docker-compose.dev.yml exec web bash  - тоже что и выше, если docker-compose-фаил с нестандартнм именем

# $ exit                                                    - выйти из внутреннего терминала контейнера


# 5. down - команда очистки, удалит все контейнеры (? все или только созданные сервисами ?), но оставит образы

# $ docker compose down                              - удалить все контейнеры созданные сервисами
# $ docker compose -f docker-compose.dev.yml down    - удалить все контейнеры если docker-compose-фаил с нестандартнм именем



puts '                                 Множество разых docker-compose и Dockerfile'

# В одной директории можно разместить несколько Dockerfile и docker-compose.yml файлов, различая их по именам. Это позволит использовать разные конфигурации, например для разработки и продакшен-окружения

# Dockerfile.dev  - например для разработки
# Dockerfile.prod - например для продакшена

# docker-compose.dev.yml  - для разработки будет использовать Dockerfile.dev через dockerfile: Dockerfile.dev
# docker-compose.prod.yml - для продакшена будет использовать Dockerfile.prod

# $ docker compose -f docker-compose.dev.yml up --build          - для запуска для разработки
# $ docker compose -f docker-compose.prod.yml up --build         - для запуска для продакшена

# Дополнительные рекомендации:
# 1. Если у вас есть общие конфигурации для обоих окружений (например, общие директивы для `docker-compose.yml`), вы можете создать один общий файл и использовать его как базу для других с помощью директивы `extends` (если используете более старую версию Compose) или использовать YAML-алиасы.
# 2. Секреты и переменные окружения: для продакшена лучше использовать `.env` файлы для хранения конфиденциальной информации и переменных окружения.
# 3. Сборка образов: Убедитесь, что ваша сборка образов для продакшена оптимизирована (например, используйте многослойные сборки, если это возможно)














#
