version: '3.1' # (!! Свойство v1, устарло и больше не используется. Компост v2 сам выбирает самую последнюю схему)


# volumes: - определяем какие у в этом проекте будут volumes, если их не существует то Докер их создаст. Указываем тут тотлько Named Volumes (?? Или и анонимные тоже ??), Host Volume тут указывать не нужно
volumes:
  pgdbdata: # определяем Named Volume директорию pgdbdata


# networks: - создает сети докера, чтобы подключить в них контейнеры в описаниях сервисов в этом фаиле. Если тут не создавать сети то создаст именованную(от имени сервиса) bridge-сеть в которую поместит все контейнеры
networks:
  # Описываем все сети что будут созданы
  internet:          # ? имя сети для использования в этом docker-compose в сервисах
    driver: bridge   # тип сети
    name: internet   # ? имя сети для Докера (! Потом назвать по разному и проверить !)
  appnet:
    driver: bridge
    name: appnet


# services - раздел со всеми сервисами, которые содержат описания контейнеров. Каждый сервис на базе обаза создает (и запускает) свой контейнер
services:

  # pgdb:  - название конкретного сервиса (можно выбирать любые названия) с СУБД PostgreSQL
  pgdb:

    # image:   - указывает образ на котором будет основан контейнер этого сервиса (скачает из Докерхаба, если его нет локально)
    image: postgres   # (имя образа, что обычно указывали в стандартной команде "run" в конце)

    # container_name - необязательная команда устанавливает название для контейнера, который будет создан на основе инструкций этого сервиса, без нее сгенерит название от имени сервиса
    container_name: postgresdb # (аналог параметра "--name" в обычной команде "run")

    # comand  - аналог CMD из Dockerfile, для команды, что исполняются при каждом запуске
    command: --default-authentication-plugin=mysql_native_password  # плагин авторизации от mysql, просто для примера

    # environment:   - переменные среды (например логин и пароль для входа)
    environment: # (аналог параметра "-e" в обычной команде "run")
      # Можно писать 2мя способами (??хз зачем??)
      # Вариант 1
      POSTGRES_PASSWORD: 12345abc99-
      # Вариант 2 (Переменные, которые нужны для подключения к БД)
      - POSTGRES_DB=postgres         # переменная названия образа(название после знака равно)
      - POSTGRES_USER=postgres			 # задаем логин
      - POSTGRES_PASSWORD=postgres   # задаем пароль

    # restart:   - настройка перезапуска контейнера если он остановлен, перезапущен сервер итд
    restart: always
    # always         - перезапускает
    # no             - не перезапускает
    # unless-stopped - после перезагрузки сервера контейнер будет иметь тоже состояние(?включен/выключен или что??), что и до перезагрузки
    # on-failure

    # volumes: - указываем какие тома мы хотим примонтировать к этому контейнеру (можно указать множество томов)
    volumes: # (аналог параметра "-v" в обычной команде "run")
      - pgdbdata:/var/lib/postgresql/data/   # Named Volume
      - /opt/web/pics:/war/www/pictures      # Host Volume   (директории и на хост машине создадутся автоматически)

    # networcks: - указываем к какой сети будет подключен контейнер этого сервиса (?? Если не указать networks: то контейнер будет подключен к сети по умолчанию ??)
    networcks:
      - appnet


  # phpmyadmin: - название другого сервиса (графического интерфейс для баз данных)
  phpmyadmin:
    image: phpmyadmin
    restart: always
    # ports: - характеристика указывающая порты, при помощи которых этот контейнер свяжется "наружу" (HOST:CONTAINER)
    ports:
      - 8080:80 # (аналог параметра "-p 8080:80" в обычной команде "run")
      - "443:443"
    environment:
      - PMA_ARBITRARY=1


  # django: сервис с Питоном, Джанго и кодом приложения, использует Dockerfile, чтобы собрать образ для контейнера этого сервиса
  django:

    # build: - указывает что нужно собрать образ на основе Dockerfile, находящегося по адресу относительному docker-compose.yml
    build: ./ # собирае от Dockerfile(Python+Django) из текущей директории

    container_name: django
    command: python manage.py runserver 0.0.0.0:8081 # запуск веб сервера Джанга
    volumes:
      - .:/usr/src/app # монтируем текущую папку "." с папкой "/usr/src/app", которая прописана в WORKDIR(рабочая директория которая будет находиться в контейнере)
    ports:
      - "8081:80"  # укажем другой порт для локального сервера(8081 вместо 8080) чтобы не было конфликтов с phpmyadmin

    # depends_on - устанавливает зависимость, тоесть этот контейнер этого сервиса будет собран (включая сборку образа) и запустиится только после укаказанных в параметрах сервисов
    depends_on:
      - pgdb # сервис django зависит от сервиса pgbd, торесть контейнер с БД будет запущен перед контейнером django-приложения
      - app-redis

    # Кнтейнер этого сервиса будет подключен к 2м сетям (назвем их внуренняя(бекенд) - доступная только контейнерам и внешняя(фронтенд) - доступная через веб для пользователей к которой мы будем перебрасывать порты), в то время как контейнеры баз данных будут подключены только к одной внутренней сети
    networcks:
      - internet # внешняя(фронтенд)
      - appnet   # внуренняя(бекенд)


    # app-redis: - сервис с БД Редис, для кеша
    app-redis:
      image: redis
      container_name: app_redis
      restart: unless-stopped
      networcks:
        - appnet


    # сервис для примера подключения контейнера к хост сети, тут не нужно подключать порты
    my_service:
      image: nginx:latest
      network_mode: host  # подключение к сети хоста, ее не нужно создавать в networks:, тк существует по умолчанию
      volumes:
        - ./html:/usr/share/nginx/html  # подключение локальной папки с HTML-страницами


    # сервис для примера запуска Ruby-программы с выводом в терминал и возможностью ввода данных через `gets`
    ruby-app:
      build: .
      # флаги `stdin_open: true` и `tty: true` позволяют взаимодействовать с приложением в терминале, используя стандартный ввод и вывод. По умолчанию Docker использует стандартный ввод (stdin) для контейнеров, но если вы делаете какие-то долгосрочные задачи или последовательные вводы, вам может быть нужно использовать `docker exec` для подключения к работающему контейнеру
      stdin_open: true  # Позволяет открытый стандартный ввод
      tty: true         # Эмулирует терминал















#
