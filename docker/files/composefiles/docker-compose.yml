version: '3.1' # (!! устаревшее свойство, больше не используется, теперь без этого свойства компост сам выбирает самую последнюю схему)


# Определяем какие у нас будут volumes, если их не существует то Докер их создаст
volumes:
  pgdbdata:        # определяем что должна быть общая папка (volume) pgdbdata


# services - все сервисы с образами и настройками, которые будут развернуты. Каждый сервис имеет свой контейнер и все эти контейнеры имеют друг в друга доступ
services:

  # pgdb:  - название конкретного сервиса (можно выбирать любые названия) с СУБД PostgreSQL
  pgdb:
    # image:   - указывам какой образ мы будем стягивать  в этот сервис (скачает из Докерхаба, если его нет локально), все остальные настройки можно скопировать в докерхабе
    image: postgres
    # comand  - аналог CMD из докерфаила, прописываем команды, что исполняются при каждом запуске
    command: --default-authentication-plugin=mysql_native_password  # плагигн авторизации от mysql, просто для примера
    # environment:   - различные настройки, переменные среды, значения, что понадобятся, например логин и пароль для входа
    environment:
      # Можно писать 2мя способами (??хз зачем??)
      # Вариант 1
      MYSQL_ROOT_PASSWORD: 12345abc99-  # задание пароля для MYSQL (просто для примера)
      # Вариант 2 (Переменные, которые нужны для подключения к БД)
      - POSTGRES_DB=postgres         # переменная названия образа(название после знака равно)
      - POSTGRES_USER=postgres			 # задаем логин
      - POSTGRES_PASSWORD=postgres   # задаем пароль
    # container_name - необязательная команда устанавливает название для контейнера
    container_name: pgdb
    # restart:   - настройка перезапуска образа если он остановлен (?изза ошбки? и если перезапустить виртуальную машину, то после рестарта Докер запустит все эти контейнеры ??) (always - перезапускает, no - не перезапускает)
    restart: always
    # volumes - указываем какие тома мы хотим примонтировать к этому контейнеру
    volumes:
      - pgdbdata:/var/lib/postgresql/data/   # создастся папка pgdbdata в рабочей папке проекта и соединяем ее с папкой на сервере по стандартному пути "/var/lib/postgresql/data/" на хост машине. Это прописывает, что все значения будут храниться на хостмашине и будут связанны с нашей папкой pgdbdata. Например наша БД с супераользователем сохранится тут и не исчесзнет если остановить контейнер (docker-compose down) и потом запустить его заново

  # phpmyadmin: - название другого сервиса (графического интерфейс для баз данных)
  phpmyadmin:
    image: phpmyadmin
    restart: always
    # ports: - характеристика указывающая порты, при помощи которых этот контейнер свяжется "наружу" (HOST:CONTAINER)
    ports:
      - 8080:80
    environment:
      - PMA_ARBITRARY=1

  # Добавим новый сервис (с Питоном и Джанго), используем уже готовый Dockerfile для того, чтобы подключить в сервис образ из него со всеми настройками
  django:
    # build - указывает что нужно собрать образ на основе Dockerfile, находящегося по относительному адресу (тут "./")
    # Чтобы сделать другие билды в этом docker-compose фаиле, можно положить докерфалы в папки разных проектов, тк это могут быть и отдельные сервисы(подпроекты) и в коде
    build: ./ # указываем папку где находится Dockerfile, относительно docker-compose.yml
    container_name: django
    comand: python manage.py runserver 0.0.0.0:8081 # тут для запуска локального веб сервера (в Джанга есть предустановленный) manage.py - спец фаил к которому мы обращаемся через Питон и вызываем команду runserver 0.0.0.0 - локалхост

    # volumes - указываем какие тома мы хотим примонтировать к этому контейнеру
    volumes:
      - .:/usr/src/app # монтируем текущую папку "." с папкой "/usr/src/app", которая прописана в WORKDIR(рабочая директория которая будет находиться в контейнере)
    ports:
      - "8081:80"  # укажем другой порт для локального сервера(8081 вместо 8080) чтобы не было конфликтов с phpmyadmin
    # depends_on - устанавливает последовательность загрузки контейнеров. (тут: сначала запустится сервис pgdb, потом django)
    depends_on:
      - pgdb # говорит о том что наш сервис (тут django) вступит в зависимость(можем через него обращаться) с другим нашим сервисом, описанным в эом же docker-compose (тут pgdb) Важно что сервис django зависит от сервиса pgbd, а не наоборот. Именно это гарантирует что контейнер с базой данных будет запущен перед контейнером приложения














#
