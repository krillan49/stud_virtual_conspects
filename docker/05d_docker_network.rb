puts '                                    Docker Network / Сети Докера'

# Все контейнеры Докера создаются в какой либо из сетей Докера

# Докер по умолчанию создет и предоставляет для контейнеров 3 основные типа сетей:
# 1. Bridge  - тип по умолчанию, выход наружу через port mapping
# 2. Host    - с ServerIP, тоесть с адресом сервера(хост машины), например 10.15.11.12
# 3. None

# Так же Докер предоставляет дополнительные типы сетей, которые можно создать:
# 4. Macvlan
# 5. IPvlan
# 6. Overlay - нужен когда Докер запускается в кластере, например Docker Swarm Cluster

# --network - параметр (?? только команды run или и других ??), который задает в сеть какого типа будет помещен созданный/запущенный контейнер

# network create - команда создания новой сети, где параметр "--driver" задает тип сети, если его не указать, то автоматически создастся сеть типа Bridge
# $ docker network create --driver тип_сети имя_сети
# $ docker network create -d тип_сети имя_сети

# network ls - команда выведет все существующие сети, их типы, айдишники
# $ docker network ls
#=>

# network inspect - команда выдает подробную информацию о конкретной сети в виде JSON, в том числе ?айдишники? этой сети
# $ docker network inspect myNetwork                - по имени сети
# $ docker network inspect 5ecde7c66384             - по айдишнику сети



puts '                                              Bridge'

# Bridge - тип сети по умолчанию и наиболее используемый тип сети. В сеть default этого типа по умолчанию попадают контейнер при его создании. Контейнеры находящиеся в сети этого типа имеют доступ наружу и могут подключаться локальному серверу хоста, к другим серверам, интернету итд. Чтобы подключиться к контейнерам из этой сети извне - нужно пробросить мост/bridge, который соединит ip-адрес контейнера с ip-адресом сервера и чтобы его создать нужно использовать параметр "-p"(port mapping), например "-p 80:80" так мы сединим порт хоста с портом контейнера.

# Может существовать множество сетей типа Bridge. Контейнеры внутри Bridge-сетей могут общаться друг с другом. Но контейнеры из разных Bridge-сетей общаться друг с другом уже не могут, это позволяет полностью изолировать отдельные приложения, чтобы единственным вариантом их взаимодействия бул через хост-машину


# default - сеть типа Bridge, существующая по умолчанию, запуская Докер контейнер, по умолчанию получаем дефоллтный Bridge серевой интерфейс(сетевую карточку) "docker0: 172.17.0.1/16". Контейнеры в этой сети могут общаться между собой по ip-адресом которые они получают автоматически в этой сети (172.17.0.2, 172.17.0.3 итд), но они не могут общаться между собой, используя свои имена (DNS)
# $ docker run nginx             - при запуске контейнера, он, по умолчанию, попадает в Bridge docker0:172.17.0.1/16


# Чтобы иметь возможность обращаться контейнерам друг другу на только по ip-адресом, но и по DNS-именам (используются имена, которые мы присваеваем через --name, либо те что создает докер автоматически), нужно создать новую, кастомную Bridge-сеть и потом создать эти контейнеры в ней.

# $ docker network create --driver bridge myNet1    - создаем новую Bridge-сеть с названием myNet1
# $ docker network create myNet1                    - создаем новую Bridge-сеть (выбирается по умолчанию) myNet1

# --net   - параметр (?? команды run или и других ??), указывающий в какую конкретную сеть типа Bridge мы хотим поместить контейнер (если не указать то поместит в default-сеть)

# $ docker run --net myNet1 nginx           - помещаем созданный контейнер в Bridge-сеть с названием myNet1
# $ docker run --net myNet1 mysql           - помещаем еще один контейнер в Bridge-сеть с названием myNet1

# Теперь контейнеры в этой новой Bridge-сети могут общаться не только по ip-адресом, но и по DNS-именам



puts '                                               Host'

# Host - тип сети в которой контейнеры получают ip-адрес хоста/сервера и отличаются от него только портами. Контейнеры находящиеся в сети этого типа имеют доступ наружу и могут подключаться локальному серверу хоста, к другим серверам, интернету итд. Чтобы подключиться к контейнеру в сети Host достаточно указать ip-адрес хоста/сервера и порт, если он отличается от порта браузера по умолчанию(80 и 443), например 10.15.11.12:8001.

# Чтобы контейнер был создан в сети Host, нужно задать значение "host" для параметра "--network"
# $ docker run nginx --network=host     - контейнер попадет в сеть Host

# Создание Host-сети. Но невозможо создать больше 1й host-сети, потому выдаст ошибку (?? потому просто создавать бессмысленно или можно удалить ту что уже создана по умолчанию ??)
# $ docker network create --driver host myNet1    =>

# Контейнеры в хост сети могут общаться между собой, но они не имеют своего ip-адреса и получают адрес самого хоста.



puts '                                               None'

# None - тип сети в которой контейнеры не получают ip-адреса и к ним невозможно подключиться извне ни локально ни через интернет, тоесть контейнеры из этой сети можно использовать только локально. Каждый контейнер в None-сети изолирован не только от подключений извне, но и от других контейнеров в None-сети

# Чтобы контейнер был создан в сети None, нужно задать значение "none" для параметра "--network"
# $ docker run nginx --network=none     - контейнер попадет в сеть None

# Создание None-сети. Но невозможо создать больше 1й host-сети, потому выдаст ошибку (?? потому просто создавать бессмысленно или можно удалить ту что уже создана по умолчанию ??)
# $ docker network create -d null myNet1    =>



puts '                                          Macvlan и IPvlan'

# Macvlan и IPvlan - тип сети в которых контейнеры получают свои собственные сетевые карточки и ip-адреса, что позволяет подключаться извне к контейнеру напрямую через его ip-адрес. Например серврер с сетевой карточкой "eth0:" c ip-адресом "172.16.10.2", каждый контейнер в сети *vlan на этом сервере получает свои сетевые карточки и ip-адреса, например "eth0:172.16.10.21" и "eth0:172.16.10.22"

# Macvlan - сетнвая карточка имеет свой mac-адрес, например "15:4a:bc:13:d2:12", а сетевая карта каждого контейнера в сети Macvlan олучает свой отдельный mac-адрес, что намного упрощает маршрутизацию

# IPvlan - сетевая карта каждого контейнера получает тот же самый mac-адрес как у сервера















#
