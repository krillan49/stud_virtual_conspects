puts '                                    Docker Network / Сети Докера'

# Все контейнеры Докера создаются в какой либо из сетей Докера и могут взаимодействовать друг с другом только в рамках этой сети, таким образом контейнеры одного приложения могут быть в своей сети и изолированы от контейнеров других приложений

# Можно подключить один контейнер ко многим сетям одновременно(?? сети одного типа или разных тоже)

# Для связи приложений (контейнеры которых изолированы отдельной сетью для каждого приложения) можно подключить контейнеры еще одного приложения ко всем этим сетям (прокси-сервер), так эти приложения смогут общаться друг с другом или пользователями только через этот прокси сервер. Это лучше в плане безопасности, чем если бы они все находились в одной сети

# Докер предоставляет для контейнеров 3 основные типа сетей и несколько дополнительных:
# 1. Bridge  - выход наружу через port mapping
# 2. Host    - ServerIP, тоесть с адресом сервера(хост машины), например 10.15.11.12
# 3. None
# 4. Macvlan
# 5. IPvlan
# 6. Overlay - нужен когда Докер запускается в кластере, например Docker Swarm Cluster

# По умолчанию в Докере уже существуют сети каждого основного типа (bridge, host, none)


# !!! Для того чтобы протестировать сети Докера стоит использовать специальный контейнер в котором будут работать сетевые команды Линукс, например https://hub.docker.com/r/nicolaka/netshoot, тк в обычных вырезается все лишнее, не нужное для работы соответсвующих технологий



puts '                                                Команды'

# Посмотреть какие сетевые карточки и айпи адреса доступны на хост машине или в контейнере можно командой линукса "ip a"
# $ ip a                      =>
# ...
# 5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
#     link/ether 6e:4f:23:62:67:d3 brd ff:ff:ff:ff:ff:ff
#     inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
# ...
# docker0         - сетевая карта Докера на нашей хост машине
# 172.17.0.1/16   - ip-адрес и маска сети(??обозначает максимум адресов в последнем параметре??) сетевой карточки Докера


# network ls - команда выведет все существующие сети, их типы, айдишники (тут сети bridge, host, none по умолчанию, доступные изначально)
# $ docker network ls               =>
# NETWORK ID     NAME                       DRIVER    SCOPE
# d4dc498e1033   bridge                     bridge    local
# 04c941da0498   host                       host      local
# fff49c747023   none                       null      local


# network create - команда создания новой сети
# -d (--driver) - параметр задает тип сети, если его не указать, то автоматически создастся сеть типа Bridge
# --subnet      - параметр указывающий адрес сети с маской сети
# --gateway     - параметр указывает ?откуда начинаются адреса сети ?? куда идут наши пакеты
# $ docker network create --driver bridge myNet1    - создаем новую Bridge-сеть с названием myNet1
# $ docker network create myNet1                    - создаем новую Bridge-сеть (выбирается по умолчанию) myNet1
# $ docker network create -d bridge --subnet 192.168.10.0/24 --gateway 192.168.10.1 myNet192


# network inspect - команда выдает подробную информацию о конкретной сети в виде JSON (в том числе, например "Subnet": "172.21.0.0/16" и "Gateway": "172.21.0.1")
# $ docker network inspect myNetwork                - по имени сети
# $ docker network inspect 5ecde7c66384             - по айдишнику сети


# network rm - команда для удаления сети, принимает имя сети или ее айди
# $ docker network rm myNet192                       - удалим по имени
# $ docker network rm 388510fd38c9                   - удалим по айди
# $ docker network rm myNet192 e87eba15f6c5          - удалим сразу 2 сети


# --net (--network | --network=)     - параметр (?? только команды run или и других ??) для указания сети (по типу сети или имени конкретной сети), к которой будет подключен созданный/запущенный контейнер. Значение можно задавать как `--network` так и `--network=` (алиасы). Сеть в которую помещаем, должна быть создана заранее. Если не указать то поместит в Bridge-default-сеть
# $ docker run nginx                              - создаем и запускаеи контейнер в сети default типа Bridge
# $ docker run nginx --network=host               - создаем и запускаеи контейнер в сети host
# $ docker run nginx --network=none               - контейнер попадет в сеть None
# $ docker run --network my_network my_image      - ?? почему тут перед образом, а выше после ??
# $ docker run --network=my_network my_image      - ?? почему тут перед образом, а выше после ??
# $ docker run --net myNet1 nginx                 - помещаем контейнер в Bridge-сеть с названием myNet1


# Чтобы посмотреть в каких сетях находятся контейнер с айдишниками и айпи и прочей инфой, можно проинспектировать контейнер
# $ docker inspect some_container


# network connect - команда чтобы подкдключить контейнер к другой сети (1 контейнер может находиться в нескольких сетях одновременно). Можно подключить контейнер прямо во время его работы

# $ docker run --rm -it --name netTest1 nicolaka/netshoot /bin/bash     - запустим контейнер в Bridge-сети default

# $ docker network connect mynet1 netTest1    - подключаем контейнер netTest1 (был в Bridge-сети default) к сети mynet1

# Проверим, что наш контейнер находится теперпь в 2х сетях
# $ ip a                =>
# 2: eth0@if18: ... inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
# 3: eth1@if20: ... inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1

# Посмотрим теперь инфу о нашем контейнере и найдем там айдишники сетей
# $ docker inspect netTest1         =>
# "Networks": {
#     "bridge": {
#         "NetworkID": "d4dc498e103315d7875e79b26171ff898b433767fd6ec63871209017936f39e3",
#         "EndpointID": "4b90b002a98b59ec763215a19014473ae11074f24445e35b2fa26801d5d92752", ...
#     },
#     "mynet1": {
#         "NetworkID": "f72d94f10a06da2ecdaa1a73045bafc9892804feb2271b342811b2e0547d5958",
#         "EndpointID": "e5cc9cfd4918ed755be8b00476992f53cfef6123112895adb50c4036e4e53c9f", ...


# network disconnect - команда дл того чтобы отключить контейнер от сети, для этого можно использовать "NetworkID" сети
# $ docker network disconnect d4dc498e103315d7875e79b26171ff898b433767fd6ec63871209017936f39e3 netTest1     - отключим контейнер netTest1 от сети (если был подключен к 2м) используя ее NetworkID. Так можно менять сеть контейнера, подключая к новой сети и отключая от старой



puts '                                              Bridge'

# Bridge - тип сети по умолчанию и наиболее используемый. Контейнеры находящиеся в сети этого типа имеют доступ наружу и могут подключаться к локальному серверу хоста, к другим серверам, интернету итд. Чтобы подключиться к контейнерам из этой сети извне - нужно пробросить мост/bridge, который соединит ip-адрес контейнера с ip-адресом хоста/сервера и чтобы его создать нужно использовать параметр "-p"(port mapping), например "-p 80:80" так мы сединим порт хоста с портом контейнера.

# Может существовать множество сетей типа Bridge. Контейнеры внутри одной Bridge-сети могут общаться друг с другом. Но контейнеры из разных Bridge-сетей общаться друг с другом уже не могут



puts '                                          Bridge - default'

# default - сеть типа Bridge, существующая по умолчанию, запуская Докер контейнер, он по умолчанию получает дефоллтный Bridge серевой интерфейс(сетевую карточку) с адресом вроде "docker0: 172.17.0.1/16".

# Если при создании контейнера не указать никакие доп параметры, то он по умолчанию попадает сеть default типа Bridge.
# $ docker run nginx             - попадает в Bridge docker0:172.17.0.1/16


# Контейнеры в default-сети могут общаться между собой по ip-адресом, которые они получают в этой сети автоматически (172.17.0.2, 172.17.0.3 итд), но они не могут общаться между собой, используя свои имена (DNS):

# Запустим 2 контейнера в Bridge-сети default и войдем в их терминалы
# $ docker run --rm -it --name netTest1 nicolaka/netshoot /bin/bash      - создадим и запустим с командой /bin/bash
# $ docker run --rm -it --name netTest2 nicolaka/netshoot /bin/bash      - создадим 2й контейнер

# Сетевые карточки, что есть в 1м контейнере
# $ ip a    =>  ... 2: eth0@if10: ... state UP group default ... inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
# Сетевые карточки, что есть в 2м контейнере
# $ ip a    =>  ... 2: eth0@if11: ... state UP group default ... inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0

# Эти 2 контейнера могут общаться в их общей default-сети по ip-адресам
# $ ping 172.17.0.3             - проверим по ip-адресу, что 1й контейнер может подключиться ко 2му
# $ ping 172.17.0.2             - проверим по ip-адресу, что 2й контейнер может подключиться ко 1му

# Проверим в какой сети находится контейнер
# $ docker inspect netTest2         => "NetworkSettings": { ..., "Networks": { "bridge": { ...



puts '                                        Bridge - кастомные сети'

# Кастомные Bridge-сети - это любые сети типа Bridge созданные вручную, они в отличие от default сети позволяют обращаться контейнерам друг к другу не только по ip-адресом, но и по DNS-именам (используются имена контейнеров). Нужно создать новую, кастомную Bridge-сеть и потом создать эти контейнеры в ней. Айпишники таких сетей будут идти после default, например: "172.18.0.1/16", "172.19.0.1/16" итд

# $ docker network create --driver bridge myNet1    - создаем новую Bridge-сеть с названием myNet1
# $ docker network create myNet1                    - создаем новую Bridge-сеть (выбирается по умолчанию) myNet1

# Создадим и подключим контейнеры в кастомную Bridge-сеть mynet1 (заодно запустим терминалы контейнеров)
# $ docker run -it --name netTest1 --net mynet1 nicolaka/netshoot /bin/bash
# $ docker run -it --name netTest2 --net mynet1 nicolaka/netshoot /bin/bash

# Контейнеры в кастомной Bridge-сети могут общаться друг с другом и по ip-адресом и по по DNS-именам
# $ ping 172.18.0.3                 - проверим по ip-адресу, что первый контейнер может подключиться ко 2му
# $ ping netTest2                   - проверим по DNS-имени, что первый контейнер может подключиться ко 2му

# Проверим в какой сети находится контейнер, там же можно посмотреть и DNS-имена
# $ docker inspect netTest1         =>
# "Networks": {  ...  "mynet1": { ...
#         "Gateway": "172.18.0.1",
#         "IPAddress": "172.18.0.2",
#         "DNSNames": [
#            "netTest1",
#            "7e7140560741"


puts '                                   Bridge port mapping (проброс мостов)'

# Если внутри контейнера, находящегося в Bridge-сети приложение слушает какой-то порт, то нужно явно указать с каким портом снаружи он будет соединен, тоесть пробросить мост, который соединит ip-адрес контейнера с ip-адресом хоста/сервера

# -p  (сточная)   - опция команды "run", позволяющая соединить порты. Например 8001:80 (HOST:CONTAINER), тут 8001 это порт открытый на сервере, который пробрасывается в контейнер, а 80 это порт контейнера. Те мы связываем по порту 8001 наш комп с портом 80 контейнера/проекта и любой запрос извне контейнера сперва приходит на порт 8001 нашего сервера и потом пробрасывется на порт 80 уже внутрь контейнера.

# -P  (заглвная) - опция команды "run", перебросит порты контейнера (что указаны в EXPOSE докерфаила) и соединит их со случайнно сгенеренными портами хост машины. Какие это порты можно посмотреть через "ps" для уже созданных контейнеров

# $ docker run -p 8001:80 some                  - запускаем some в default и устанвливаем для него связанные порты
# $ docker run -d -p 80:80 some                 - устанвливаем одноименные связанные порты 80:80
# $ docker run -p 80:80 -p 3000:3000 some       - пробрасываем нескольо портов в один контейнер
# $ docker run -P some                          - пробрасываем порт контейнера с рандомным портом для хоста

# Далее моржно запускать приложение в браузере, например по дресу http://localhost:8001

# Если еть несколько контейнеров, которые надо соединить портами с сервером, тогда нужно у них сделать разные порты со стороны сервера, чьтобы не возникло конфликта и ошибки

# Если посмотреть инфу о контейнерах (docker ps), то там указвна инфа о порте который открыт в контейнере и если в него пробрасывется порт сервера, то он тоже указан

# В описании образов на Докерхаб можно найти инфу о том какие порты нужно использовать для них(для их технологий ?? или они там отбалды придуманы ??)



puts '                                               Host'

# Host - тип сети в которой контейнеры получают ip-адрес хоста/сервера и отличаются от него только портами. Контейнеры находящиеся в сети этого типа имеют доступ наружу и могут подключаться к локальному серверу хоста, к другим серверам, интернету итд. Чтобы подключиться к контейнеру в сети Host достаточно указать ip-адрес хоста/сервера и порт, если он отличается от порта браузера по умолчанию(80 и 443), например 10.15.11.12:8001.

# Чтобы контейнер был создан в сети Host, нужно задать значение "host" для параметра "--network"
# $ docker run nginx --network=host     - контейнер попадет в сеть Host

# Контейнеры в хост сети могут общаться между собой, но они не имеют своего ip-адреса и получают адрес самого хоста. Соединение по имени контейнера (DNS) мжду двумя контейнерами в host-сети не работает. Можно проверить через команду "ping" (??а по айпи как там же один и тот же тоесть мы будем пинговать саму хост машину??)

# $ docker run --rm -it --name netTest1 --net host nicolaka/netshoot /bin/bash     - и если мы используем коменду "ip a" то увидим в контейнере точно те же самые сетевые интефейсы, что и на нашей хост-машине.

# Невозможо создать больше 1й host-сети, тк контейнер будет использовать сетевую карточку сервера ??, потому выдаст ошибку (?? потому просто создавать бессмысленно или можно удалить ту что уже создана по умолчанию ??)
# $ docker network create --driver host myNet1   => Error response from daemon: only one instance of "host" network is allowed

# Использование режима сети `host` может иметь свои риски с точки зрения безопасности, так как контейнер будет иметь полный доступ к сети хост



puts '                                               None'

# None - тип сети в которой контейнеры не получают ip-адреса и к ним невозможно подключиться извне ни локально ни через интернет, тоесть контейнеры из этой сети можно использовать только локально. Каждый контейнер в None-сети изолирован не только от подключений извне, но и от других контейнеров в None-сети

# Чтобы контейнер был создан в сети None, нужно задать значение "none" для параметра "--network"
# $ docker run nginx --network=none     - контейнер попадет в сеть None

# Невозможо создать больше 1й None-сети, потому выдаст ошибку (?? потому просто создавать бессмысленно или можно удалить ту что уже создана по умолчанию ??)
# $ docker network create -d null myNet1   => Error response from daemon: only one instance of "null" network is allowed

# Проверим контейнер в none сети, где у него будет только сетевая карточка локалхоста
# $ docker run --rm -it --name netTest1 --net none nicolaka/netshoot /bin/bash
# $ ip a                      =>
# 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
#     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
#     inet 127.0.0.1/8 scope host lo
#        valid_lft forever preferred_lft forever
#     inet6 ::1/128 scope host
#        valid_lft forever preferred_lft forever



puts '                                          Macvlan и IPvlan'

# Macvlan и IPvlan - типы сети, при создании которых создается DHTP-сервер, тоесть контейнеры в этих сетях получают свои собственные сетевые карточки и ip-адреса в этой сети, что позволяет подключаться извне к контейнеру напрямую через его ip-адрес. Например серврер с сетевой карточкой "eth0:" c ip-адресом "172.16.10.2", каждый контейнер в сети *vlan на этом сервере получает свои сетевые карточки и ip-адреса, например "eth0:172.16.10.21" и "eth0:172.16.10.22"

# Используются для работы с сетью, фаерволами, прокси итд

# Macvlan - сетевая карта каждого контейнера в сети Macvlan олучает и свой отдельный mac-адрес, например "15:4a:bc:13:d2:12", что намного упрощает маршрутизацию

# IPvlan - сетевая карта каждого контейнера получает тот же самый mac-адрес как у сервера


# --ip-range       - флаг указывает ??диапазон/макситмально возможный адрес?? ip-адресов или только этот конкретный адрес ??
# -o parent=       - опция указывает с какой сетевой карточкой на сервере будет спарена (значение это имя сетевой карточки, его можно посмотреть через "ip a" на сервере)

# $ docker network create -d macvlan --subnet 192.168.100.0/24 --gateway 192.168.100.1 --ip-range 192.168.100.99/32 -o parent=wlp0s20f3 myMACvlan

# Создадим и запустим контейнер в этой сети и проверим, что контейнер имеет айпи адрес заданный в --ip-range
# $ docker run --rm -it --name netTest1 --net myMACvlan nicolaka/netshoot /bin/bash
# $ ip a   => ... 23: eth0@if3: ... inet 192.168.100.99/24 brd 192.168.100.255 scope global eth0


# Можно создать не просто рандомную сеть, а соответсвующую сетеой карточке хост машины, адрес которой, например 192.168.1.36/24, тоесть адрес 192.168.1.35 точно свободен

# $ ip a  => 3: wlp0s20f3: ... inet 192.168.1.36/24 brd 192.168.1.255 scope global dynamic noprefixroute wlp0s20f3

# $ docker network create -d macvlan --subnet 192.168.1.0/24 --gateway 192.168.1.1 --ip-range 192.168.1.35/32 -o parent=wlp0s20f3 myMACvlan

# Создадим и запустим контейнер в этой сети
# $ docker run --rm -it --name netTest1 --net myMACvlan nicolaka/netshoot /bin/bash

# Так же можем запустить контейнер в этой сети и с другим конкретным айпи адресом дополнительно, указав его через флаг --ip
# $ docker run --rm -it --name netTest2 --ip 192.168.1.34 --net myMACvlan nicolaka/netshoot /bin/bash

# Проверим в контейнере
# $ ip a  => ... 24: eth0@if3:  ... inet 192.168.1.35/24 brd 192.168.1.255 scope global eth0

# (!!?? Но почему-то связь от сервера, через команду ping в эту сеть не проходит хотя в видосе проходила ??)






















#
