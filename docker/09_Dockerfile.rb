puts '                                             Dockerfile'

# https://docs.docker.com/reference/dockerfile/

# Dockerfile (можно без расширений или добавить кастомные, можно и со строчной буквы) - фаил содержит инструкцию как именно нужно упаковать приложение в наш новый образ. Содержит подключаемые образы, которые будут базой для нашего нового образа, дополнительные фаилы и различные настройки и конфигурции для образов и подключаемых технологий.

# Готовое срдержание для Dockerfile есть на странице каждого образа в Docker Hub, можно скопировать оттуда, чтобы создать точно такой же образ самому или добавить его в свой составной образ

# Dockerfile состоит из разных команд, они запускаются послеовательно сверху вниз по расположению в Dockerfile (это можно проследить в выводе терминала когда будет собираться образ), нужно это учитывать при их записи. Каждая команда при сборке образа будет "слоем" в "слоеном пироге" образа, который изначально состоит из "слоев" из которых собран образ из команды FROM (тк например для работы питона нужен какой-то фунеционал от ОС, настройки итд)

# Можно задавать несколько одинаковых команд в одном Dockerfile, пример Dockerfile(python+app), где 2 команды RUN



puts '                                               FROM'

# FROM – команда Dockerfile указывает какой образ будет использован(скачает из Докер Хаба если его у нас нет локально) как базовый, с которого мы начнем сборку нашего образа. Можно дополнительно указать через двоеточие "тег"(например с версией :11), по умолчанию будет последняя версия. Можно после версии указать еще и сервер(например -apache).

# FROM php:7.2-apache                  - образ php версии 7.2, сервер apache
# FROM python:3.6                      - образ python версии 3.6



puts '                                               LABEL'

# LABEL – команда Dockerfile, при помощи которой можно указать любую дополнительную информацию о нашем образе, задать любые имена параметров и их значения

# LABEL author=krillan49               - автор образа
# LABEL type=demo
# LABEL power=9000

# $ docker image inspect my_image      - среди вывода в блоке "lables" будут и все указнные автором переменные из LABEL



puts '                                              WORKDIR'

# WORKDIR – команда Dockerfile указывает рабочую директорию в образе. Все команды в контейнере будут выполняться относительно этого каталога. Это папка по умолчанию, в которой будет запускаться среда разработки. Можно назвать её как угодно.

# WORKDIR /usr/src/myapp                - устанавливаем директорию /usr/src/myapp в контейнере рабочей
# WORKDIR /home/app

# При входе в контейнер в интерактивном режиме через команды exec или run мы сразу оказываемсчя в рабочей директоррии
# $ docker exec -it myproject bin/bash          - теминал будет в рабочей директории



puts '                                               COPY'

# COPY – команда Dockerfile указывает какие директории и файлы будут скопированы с хост машины в образ. Принимает 2 параметра: путь к фаилам на нашем ПК (относительно расположения Dockerfile), которые хотим скопировать; путь в контейнере, куда копируем.

# COPY . /usr/src/myapp                  - копируем содержимое текущей диретории в директорию контейнера "/usr/src/myapp"
# COPY /files2/script.sh /opt/script.sh  - копируем фаил /files2/script.sh в фаил /opt/script.sh
# COPY requirements.txt ./               - копируем фаил requirements.txt в рабочую директорию, если она установлена в WORKDIR, иначе нужно прописать полный путь, например /usr/src/app



puts '                                              EXPOSE'

# EXPOSE – команда Dockerfile декларирует(сам проброс не выполняется) порт для контейнера, который будем пробрачывать наружу(из контейнера), команда чисто информационная, для того чтобы пользователи образа знали какие порты нужно использовать. Можно использовать эту команду несколько раз, чтобы указать несколько портов. Помогает так же флагу -P автоматически подобрать порты

# EXPOSE 80                   - декларируем что будем пробрасывать порт контейнера 80 наружу для локального компьютера
# EXPOSE 8001                 - декларируем что будем пробрасывать наружу порт 8001
# EXPOSE 443/tcp              - порт 443 который можно использовать только по протоколу tcp

# $ docker image inspect my_image      - среди вывода в блоке "EposedPorts" будут и все указнные в EXPOSE порты
# $ docker ps                          - порты из EXPOSE показывает и в инфк о контейнерах



puts '                                               RUN'

# RUN – команда Dockerfile, что выполнится один раз при создании образа (?? выполняется относительно WORKDIR рабочей директории образа ??). Содержит команды, которые нужно выполнить в терминале. Любые команды технологий приложения, которое будет запакованно в образ, так же можно создавать новые директории и выполнять другие команды терминалов.

# RUN	javac Main.java                  - запускаем компилятор Джавы javac и компилируем исполняемый фаил Main.java
# RUN mkdir -p /usr/src/app/           - создаем директорию /usr/src/app/
# RUN pip install -r requirements.txt  - берем библиотеки из фаила requirements.txt и устанавливаем их (pip бандлер Питона)
# RUN cmod a+x ./run.sh                - установим права на запуск фаила run.sh (там например длинная команда запуска веб сервера)
# RUN gem install rails                - установим Ruby on Rails
# RUN apt-get update -qq && apt-get install -y nodejs   - установим Node.js (флаг -y чтобы не спрашивало подтверждение на установку)



puts '                                               ENV'

# ENV - команда Dockerfile указывающая переменные окружения среды в образе по умолчанию, например временную зону, какието айдишники, какието адреса на внешние сервисы итд. Команда принимает переменную окружения и через пробел или = ее значение

# ENV TZ Europe/Moscow                 - добавляем переменную окружения с именем "TZ", в которой задаем временную зону Москвы
# ENV PORT 3000                        - установит переменную с именем $PORT в вашем терминале bash на значение «3000»
# ENV TYPE=demo                        - установим через синтаксис с =

# Можем использовать переменные в других командах Dockerfile например в RUN, EXPOSE итд, вызывая их через $
# EXPOSE $PORT                         - пробросим порт 3000
# RUN echo $TYPE > /opt/info.txt       - запишем значение переменно в фаил
# CMD ["cat", "/opt/info.txt"]         - отобразим фаил со значением переменной

# При входе в контейнер в интерактивном режиме через команды exec или run можно посмотреть установленные переменные окружения при помощи команды "env"

# $ docker image inspect my_image      - среди вывода в блоке "Env" будут все заданные переменные и их значения

# Если переменные окружения меняются, то можно их задать с нуля или переназначить те, что указаны в Dockerfile через опции команды run, через флаг -e. Но хоть переменные и поменяюся в интерактивном режиме, это не повлияет на "CMD ["cat", "/opt/info.txt"]" в примере выше, тк оно берет значение из фаила который создан еще на стадии создания образа "RUN echo $TYPE > /opt/info.txt"



puts '                                          CMD и ENTRYPOINT'

# CMD и ENTRYPOINT - команды Dockerfile сообщают Docker, какую команду нужно выполнять в терминале при каждом запуске контейнера от этого образа (docker start / docker run) (?? выполняется относительно WORKDIR рабочей директории образа ??)


# 1. CMD – Выполняет команды через Shell, тоесть запускается оболочка /bin/sh (тоже что в верхней строке шелл скриптов), эта команда изменяемая, потому мы можем при запуске контейнера через команду run заменить командой-параметром команду из CMD

# CMD echo "Hello"                     - обычный синтаксис (не рекомедуется)
# CMD ["echo", "Hello"]                - экзекьют синтаксис (рекомедуется)
# CMD ["python", "app.py"]             - будет выполнять команду "python app.py", тоесть запустит скрипт на Питоне
# CMD ["nginx", "-g", "daemon off;"]   - запустит nginx
# CMD ["java", "Main"]                 - будет выполнять команду "java Main.java", тоесть запустит скомпилированный при помощи "RUN javac Main.java" фаил

# $ docker run -it my_image /bin/bash      - команда /bin/bash сработает и заменит собой команду из CMD


# 2. ENTRYPOINT - выполняет команды без использования Shell(/bin/sh). Потому команда из ENTRYPOINT фиксирована и будет выполнена в любом случае и ее невозможно перезаписать параметром команды run

# ENTRYPOINT ["python", "app.py"]
# ENTRYPOINT ["./run.sh"]              - запустим скрипт run.sh (там например длинная команда запуска веб сервера)
# ENTRYPOINT ["/bin/bash"]             - запустим терминал bash, чтобы получить доступ к Rails

# $ docker run -it my_image /bin/bash      - команда /bin/bash не сработает и все равно будет выполнена команда из ENTRYPOINT


# 3. CMD и ENTRYPOINT можно использовать в одном Dockerfile вместе, чтобы при использовании параметра команды run заменялассь только часть команды (CMD) а другая часть (ENTRYPOINT) оставалась неизменной, например:
# ENTRYPOINT ["echo"]               - тоесть передает команду, которую не затронет параметр run
# CMD ["Hello"]                     - передает значение для команды из ENTRYPOINT, которое мы можем изменить в run

# $ docker build -t my_test:v1 .
# $ docker run -rm -it my_test:v1          => "Hello"   (наше значение по умолчанию из CMD)
# $ docker run -rm -it my_test:v1 Hi       => "Hi"      (значение по умолчанию из CMD заменилось на "Hi")


# 4. Можно скопировать скрипт при помощи COPY, а потом запускать его в CMD или ENTRYPOINT, а уже в этом скрипте будет множество всяких команд. Так будет намного удобнее выполнять множество команд при запуке контейнера
# COPY /files/script.sh /opt/script.sh         - копируем скрипт /files2/script.sh в фаил /opt/script.sh
# RUN chmod +x /opt/script.sh                  - добавим возможность запуска скрипта
# CMD ["/opt/script.sh"]                       - запустим скрипт /opt/script.sh



puts '                                         build (Сборка образа)'

# build - команда позволяет построить наш образ по инструкции из Dockerfile. Нужно прописать путь к созданному Dockerfile и опционально можно задать имя образу. Потом если выполнить 'docker images' мы увидим новый созданный образ в списке, у которого есть айди и можем даллее запустить его при помощи "run" если нужно.
# id образа(есть так же у каждого слоя) это хэш-сумма SHA-256

# -t   - флаг задает название образа. Нельзя чтоб название образа содержало спец символы и символы в верхнем регистре

# > docker build ./php                   - собираем образ по Dockerfile, который находится по пути "./php"
# > docker build -t my-php-app ./php     - собираем образ и даем ему название "my-php-app"
# $ docker build -t hello-world .        - собираем образ с названием hello-world, из текущей директории "."


# $ docker run -rm -it hello-world /bin/bash    - запуск образа с командой входа в терминал
# > docker run -p 8001:80 -d my-php-app         - запуск образа с указанием портов и командой по умолчанию(CMD) Порт который работает на нашем компе (8001) можно указывать каким угодно именно его указываем после локалхосст в адресе. А связываться мы будем с портом который прописали в строке EXPOSE














#
