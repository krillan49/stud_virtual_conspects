puts '                                             Docker Compose'

# https://docs.docker.com/compose/

# docker compose (с пробелом) - это новый вариант compose на Go. Изначальный вариант compose на python, называемый docker-compose (команды были тоже с дефисом) устарел, и разработка перешла на v2.

# Docker Compose - это надстройка над Докером, для запуска и управления многоконтейнерными или просто содержщими много параметров Docker-приложениями. Позволяет поместить в отдельный фаил все инструкции чтобы: подключить и/или сбилдить на основе Dockerfile-ов образы, указывать прследовательность подключения контейнеров, тома, сети и любые другие настройки, которые без него пришлось бы прописывать вручную как параметры с отдельными командами(build, run). И потом просто запустить все одной командой.

# Используется для управления одним или несколькими контейнерами
# Содержит инструкции по запуску контейнеров, которые будут сохрангены и их можно бужет передать
# Упрощает автоматизацию запуска контейнеров (не нужно каждый раз вводить много параметров как при запуске контейнра с обычной командой "run")

# docker-compose.yml - файл используется для описания всех связанных с проектом сервисов и взаимодействия между ними. Каждый из сервисов описывает контейнер: образ от которого будет запуен контейнер (при запуске проэкта эти образы будут либо скачаны, либо собраны и/или запущены), параметры запуска контейнера (порты, переменные среды итд).

# В Докер Хабе, на странице образа, внизу есть содержание для фаила docker-compose.yml по которому можно сбилдить точно такой же образ. Так же там ниже есть список всех переменных которые можно дописать дополнительно(например изменение логина, хоста итд)


# $ docker compose version                 => Docker Compose version vN.N.N



puts '                                       Параметры docker-compose.yml'

# docker-compose.yml  - пример где описано несколько сервисов

# Каждый сервис из docker-compose.yml можно модифицировать, например поменять значение параметра "image", подключив другой образ, например "mariadb" вместо "mysql", поменять другие настройки, например пароль из парапметра "MYSQL_ROOT_PASSWORD", добавить новые параметры или убрать старые.

# Можно удалить или добавить новый сервис, написав его настройки вручную или скопировать с докерхаб

# Если нескольо сервисов имеют порты, то стоит задать им разные порты для хост маштины, чтобы заходить на локалхосты уже в 2х вкладках в разных портах для разных сервисов и чтобы при этом не было конфликтов


# $ docker compose run django django-admin startproject itproger .          - обращаемся к контейнеру "django" описанному в сервисе в docker-compose и передаем в него команду "django-admin startproject my_project .", чтобы создать новый проект Джанго в текущей директоии
# $ docker compose up     - все равно необходимо чтобы запустить контейнеры на постоянную обработку(тоесть например запустить сервер). Тут, чтобы зайти на указанный нами localhost:8081 и запустить приложение Джанга



puts '                                       Сборка и использование образа'

# -f   - флаг для всех "docker compose" команд. Если название docker-compose-фаила нестандартное, например "docker-compose.dev.yml" то нужно его дополнительно указывать в командах под этим флагом


# 1. build - команда собирает образы описанные в сервисах docker-compose.yml, получает оттуда Dockerfile или стягивает необходимые образы и устанавливает всё остальное из docker-compose.yml. При повтороном запуске пересоберет тот же образ, а не создаст новый. По сути нужна только если сами собираем образы от Dockerfile

# $ docker compose build                            - сборка образов для всех сервисов описанных в фаиле docker-compose.yml
# $ docker compose build service_name               - сборка образа для конкретного сервиса из docker-compose.yml
# $ docker compose -f docker-compose.dev.yml build  - собрать на основе конкретного docker-compose фаила


# 2. up - команда запуска проекта (всех контейнеров), (который был собран(build) если это нужно) на основе сервисов из docker-compose.yml, создает и запускает контейнеры для каждого сервиса и все что для них нужно (тома, сети, команды). При повторном запуске запустит те же контейнеры, что были ранее созданы.

# --build    - флаг команды up чтобы пересобрать образы перед тем, как запустить контейнеры. Тоже что и запуск "build" и "up" отдельно. Удобно, если внесены изменения в код приложения, Dockerfile или docker-compose.yml

# $ docker compose up             - запуск контейеров всех сервисов (Ctrl + C выход из режима работы приложения в консоли)
# $ docker compose up -d          - запуск контейнеров всех сервисов в фоновом режиме
# $ docker compose up some        - запуск конкретного сервиса some и всех связанных с ним сервисов (depends_on)
# $ docker compose up --build     - запуск всех сервисов, с предварительной пересборкой образов для них
# $ docker compose -f docker-compose.prod.yml up --build    - собрать и запустить на основе конкретного docker-compose фаила

# Результат работы веб приложения можно увидеть в браузере, если открыть 0.0.0.0 с нужным портом, например 0.0.0.0:3000

# В выводе терминала логи разбиты по именам контейнеров(или сервисов??), это помечено в каждой строке логов скраю слева именем и отделено "|"

# logs -f  - Если контейнеры запущены с опцией "-d" в фоновом режиме, то можно открыть обычный режим с логами при помощи этой команды
# $ docker compose logs -f


# 3. run - команда собирает образы (как build), создает на основе них и запускает контейнер (как up) для ?одного? указанного сервиса (имя сервиса из docker-compose.yml) и дополнительно может передать в контейнер для исполнения команду. При повторных запусках будет каждый раз создавать новый контейнер

# $ docker compose run [OPTIONS] SERVICE [COMMAND]
# SERVICE - имя сервиса из `docker-compose.yml`, для которого нужно запустить новый контейнер
# COMMAND - команда (и арументы для нее), которую нужно выполнить внутри контейнера. Если команда не указана, то будет использоваться команда по умолчанию из `Dockerfile` или из `docker-compose.yml` (из command или из CMD)

# --rm             - удалить контейнер после завершения его работы
# --service-ports  - пробросить порты, заданные в сервисе (по умолчанию `run` порты не пробрасывает)
# -d (--detach)    - запускает контейнер в фоновом режиме
# --name           - указывает имя контейнера. (По умолчанию, Docker создаст имя автоматически)
# -e (--env)       - устанавливает переменные окружения для контейнера. Можно указать несколько переменных, повторяя флаг.
# --user           - задает пользователя и группу, от чьего имени будет запущен командный процесс в контейнере.

# $ docker compose run web                               - запуск сервиса web с использованием команды по умолчанию
# $ docker compose run --rm --service-ports ruby_dev     - запуск сервиса ruby_dev с пробросам портов
# $ docker compose run web rake db:create                - запуск сервиса web и передача команды rake db:create в контейнер
# $ docker compose -f docker-compose.dev.yml run web rake db:create  - если имя docker-compose-фаила нестандартное


# 4. exec - если нужно работать внутри терминала запущенного контейнера, то можно открыть новый терминал и выполнить эту команду. Эта команда откроет указанную в параметре оболочку внутри выбранного контейнера, и позврлит запускать ее команды.

# $ docker compose exec web bash               - работать с терминалом bash внутри контейнера (запустить в новом терминале)
# $ docker compose -f docker-compose.dev.yml exec web bash  - тоже что и выше, если docker-compose-фаил с нестандартнм именем

# $ exit                                                    - выйти из внутреннего терминала контейнера


# 5. stop - останавливает все работающие контейнеры запущенные при помощи docker compose команд от docker-compose.yml

# $ docker compose stop               - остановить все контейнеры


# 6. down - команда очистки, удалит все контейнеры (? все или только созданные сервисами ?), но оставит образы

# $ docker compose down                              - удалить все контейнеры созданные сервисами
# $ docker compose -f docker-compose.dev.yml down    - удалить все контейнеры если docker-compose-фаил с нестандартнм именем



puts '                                 Множество разых docker-compose и Dockerfile'

# В одной директории можно разместить несколько Dockerfile и docker-compose.yml файлов, различая их по именам. Это позволит использовать разные конфигурации, например для разработки и продакшен-окружения

# Dockerfile.dev     - для разработки
# Dockerfile.prod    - для продакшена

# docker-compose.dev.yml     - для разработки будет использовать Dockerfile.dev через dockerfile: Dockerfile.dev
# docker-compose.prod.yml    - для продакшена будет использовать Dockerfile.prod

# $ docker compose -f docker-compose.dev.yml up --build          - запуск для разработки
# $ docker compose -f docker-compose.prod.yml up --build         - запуск для продакшена

# Дополнительные рекомендации:
# 1. Если есть общие конфигурации для обоих окружений (например, общие директивы для `docker-compose.yml`), можно создать один общий файл и использовать его как базу для других с помощью директивы `extends` (если используете более старую версию Compose) или использовать YAML-алиасы.
# 2. Для продакшена лучше использовать `.env` файлы для хранения конфиденциальной информации и переменных окружения.
# 3. Убедитесь, что сборка образов для продакшена оптимизирована (например, используйте многослойные сборки, если это возможно)














#
